#!/usr/bin/env node
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));

// node/utils.ts
var import_pathe = __toESM(require("pathe"));
var import_fs = __toESM(require("fs"));
var import_dotenv = require("dotenv");
var import_get_packages = require("@manypkg/get-packages");
var root = process.cwd();
function setup(root2 = "", hook) {
  const source = process.cwd;
  if (root2)
    process.cwd = () => root2;
  const result = hook();
  process.cwd = source;
  return result;
}
function dokey(file2) {
  var _a2;
  const filepath = find(file2);
  const root2 = filepath ? import_pathe.default.dirname(filepath) : void 0;
  const envs = (0, import_dotenv.config)({ processEnv: {}, path: filepath });
  const DOTENV_KEY = ((_a2 = envs.parsed) == null ? void 0 : _a2.DOTENV_KEY) || process.env.DOTENV_KEY;
  return { root: root2, filepath, DOTENV_KEY };
}
function find(file2) {
  let currentDir = root;
  while (currentDir !== import_pathe.default.parse(currentDir).root) {
    const envPath = import_pathe.default.join(currentDir, file2);
    if (import_fs.default.existsSync(envPath)) {
      return envPath;
    }
    currentDir = import_pathe.default.dirname(currentDir);
  }
  return void 0;
}
function write(filepath, parsed = {}) {
  const contents = Object.entries(parsed).map(([key, value]) => `${key}=${value}`);
  const content = [
    "# This file is generated by lnv command",
    "# DO NOT ATTEMPT TO EDIT THIS FILE",
    contents.join("\n")
  ].join("\n");
  import_fs.default.writeFileSync(filepath, content, "utf-8");
}
async function exposes(parsed = {}) {
  const { packages } = await (0, import_get_packages.getPackages)(process.cwd());
  for (const pack of packages) {
    console.log(` - ${import_pathe.default.relative(root, pack.dir)}/.env`);
    write(`${pack.dir}/.env`, parsed);
  }
}
async function expose(parsed = {}) {
  write(`${root}/.env`, parsed);
}

// node/cli.ts
var import_yargs = __toESM(require("yargs"));
var import_helpers = require("yargs/helpers");

// package.json
var version = "2.1.0";

// node/cli.ts
function parse() {
  return (0, import_yargs.default)((0, import_helpers.hideBin)(process.argv)).scriptName("lnv").showHelpOnFail(false).version(version).usage("$0 <mode> [args]").alias("h", "help").alias("v", "version").option("run", {
    describe: "load runtime environment and run any scripts",
    type: "array",
    alias: "r",
    string: true
  }).option("monorepo", {
    describe: "apply to packages in the monorepo.",
    type: "boolean",
    alias: "m"
  }).option("expose", {
    describe: "expose environment variables",
    alias: "e",
    type: "boolean"
  }).help().parse();
}

// node/index.ts
var import_dotenv2 = require("dotenv");
var args = parse();
if (!args.monorepo && !args._[0])
  throw new Error(`Please enter lnv <mode> the loading mode`);
var dotenv = args._[0] === "dotenv";
var mode = args._[0];
var file = dotenv ? ".env.vault" : mode ? `.env.${mode}` : ".env";
var _a;
var command = ((_a = args.run) == null ? void 0 : _a.join(" ")) || "";
var suffix = args.expose ? args.monorepo ? "packages by" : ".env" : "runtime environment";
var successfullyMessage = dotenv ? `Successfully decrypted ${file} to ${suffix}` : `Successfully loaded ${file} to ${suffix}`;
command && (successfullyMessage += "\n");
async function main() {
  const envs = dotenv ? loadVault() : loadLocal();
  if (envs.error)
    return;
  console.log(successfullyMessage);
  const { execa } = await import("execa");
  command && execa(command, { env: envs.parsed, stdout: "inherit" });
  if (args.expose) {
    args.monorepo ? await exposes(envs.parsed) : await expose(envs.parsed);
  }
}
main();
function loadLocal() {
  return (0, import_dotenv2.config)({ path: find(file) });
}
function loadVault() {
  const { DOTENV_KEY, root: root2 } = dokey(".env.key") || dokey(".env");
  if (!DOTENV_KEY)
    throw new Error("no DOTENV_KEY found in .env | .env.key or process.env");
  return setup(root2, () => (0, import_dotenv2.config)({ DOTENV_KEY }));
}
