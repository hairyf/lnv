#!/usr/bin/env node
var N=Object.create;var g=Object.defineProperty;var F=Object.getOwnPropertyDescriptor;var I=Object.getOwnPropertyNames;var K=Object.getPrototypeOf,P=Object.prototype.hasOwnProperty;var V=(e,n,s,o)=>{if(n&&typeof n=="object"||typeof n=="function")for(let i of I(n))!P.call(e,i)&&i!==s&&g(e,i,{get:()=>n[i],enumerable:!(o=F(n,i))||o.enumerable});return e};var p=(e,n,s)=>(s=e!=null?N(K(e)):{},V(n||!e||!e.__esModule?g(s,"default",{value:e,enumerable:!0}):s,e));var c=p(require("pathe")),u=p(require("fs")),y=require("dotenv"),h=require("@manypkg/get-packages"),d=process.cwd();function f(e){return(0,y.config)({processEnv:{},path:a(e)}).parsed?.DOTENV_KEY}function a(e){let n=d;for(;n!==c.default.parse(n).root;){let s=c.default.join(n,e);if(u.default.existsSync(s))return s;n=c.default.dirname(n)}}function x(e,n={}){let o=["# This file is generated by lnv command","# DO NOT ATTEMPT TO EDIT THIS FILE",Object.entries(n).map(([i,t])=>`${i}=${t}`).join(`
`)].join(`
`);u.default.writeFileSync(e,o,"utf-8")}async function w(e={}){let{packages:n}=await(0,h.getPackages)(process.cwd());for(let s of n)console.log(` - ${c.default.relative(d,s.dir)}/.env`),x(`${s.dir}/.env`,e)}async function E(e={}){x(`${d}/.env`,e)}function b(e){let n=[],s="",o=!1,i="";for(let t of e)t.startsWith("'")||t.startsWith("`")?o?s+=" "+t.slice(1):(o=!0,i=t[0],s+=t.slice(1)):t.endsWith("'")||t.endsWith("`")?o&&i===t[t.length-1]?(s+=" "+t.slice(0,-1),n.push(s.trim()),s="",o=!1):n.push(t):o?s+=" "+t:n.push(t);return s&&n.push(s.trim()),n}var k=p(require("yargs")),$=require("yargs/helpers");var T="3.5.0";function O(){return(0,k.default)(b((0,$.hideBin)(process.argv))).scriptName("lnv").showHelpOnFail(!1).version(T).usage("$0 <mode> [args]").alias("h","help").alias("v","version").option("run",{describe:"load runtime environment and run any scripts",type:"string",alias:"r"}).option("monorepo",{describe:"apply to packages in the monorepo.",type:"boolean",alias:"m"}).option("expose",{describe:"expose environment variables",alias:"e",type:"boolean"}).help().parse()}var v=require("dotenv"),D=require("child_process"),r=O();if(!r.monorepo&&!r._[0])throw new Error("Please enter lnv <mode> the loading mode");var m=r._[0]==="dotenv",S=r._[0],l=m?".env.vault":S?`.env.${S}`:".env",Y=r.monorepo?w:E,j=r.expose?r.monorepo?"packages by":".env":"runtime environment",_=m?`Successfully decrypted ${l} to ${j}`:`Successfully loaded ${l} to ${j}`;r.run?.length&&(_+=`
`);async function A(){let e=m?R():Q();e.error?console.log(`Failed to load ${l}, searched upwards, but the file was not found`):console.log(_),r.run&&await C(r.run,e.parsed),r.expose&&await Y(e.parsed)}A();function Q(){return(0,v.config)({path:a(l)})}function R(){let e=f(".env.key")||process.env.DOTENV_KEY||f(".env");if(!e)throw new Error("no DOTENV_KEY found in .env | .env.key or process.env");return(0,v.config)({DOTENV_KEY:e,path:a(".env.vault")})}async function C(e,n){Array.isArray(e)&&(e=e.join(" "));let s={stdio:"inherit",env:{...process.env,...n}};try{let{execaSync:o}=await import("execa");o(e,s)}catch{(0,D.execSync)(e,s)}}
