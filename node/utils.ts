import path from "pathe"
import fs from "fs"
import { config } from 'dotenv'
import { getPackages } from '@manypkg/get-packages';
const root = process.cwd()

export function setup<T>(root = '', hook: () => T) {
  const source = process.cwd
  if (root)
    process.cwd = () => root
  const result = hook()
  process.cwd = source
  return result
}
export function dokey(file: string) {
  const envs = config({ processEnv: {}, path: find(file) })
  return envs.parsed?.DOTENV_KEY
}

export function find(file: string) {
  let currentDir = root;

  while (currentDir !== path.parse(currentDir).root) {
    const envPath = path.join(currentDir, file);
    if (fs.existsSync(envPath)) {
      return envPath;
    }
    currentDir = path.dirname(currentDir);
  }

  return undefined;
}

export function write(filepath: string, parsed = {}) {
  const contents = Object.entries(parsed)
    .map(([key, value]) => `${key}=${value}`)
  const content = [
    "# This file is generated by lnv command",
    '# DO NOT ATTEMPT TO EDIT THIS FILE',
    contents.join('\n'),
  ].join('\n')
  fs.writeFileSync(filepath, content, 'utf-8')
}

export async function exposes(parsed: Record<string, string> = {}) {
  const { packages } = await getPackages(process.cwd())
  for (const pack of packages) {
    console.log(` - ${path.relative(root, pack.dir)}/.env`)
    write(`${pack.dir}/.env`, parsed)
  }
}

export async function expose(parsed: Record<string, string> = {}) {
  write(`${root}/.env`, parsed)
}

export function parseQuotes(argv: string[]) {
  const result = [];
  let currentString = '';
  let inQuotes = false;
  let quoteChar = '';

  for (const arg of argv) {
      if (arg.startsWith("'") || arg.startsWith("`")) {
          if (inQuotes) {
              currentString += ' ' + arg.slice(1);
          } else {
              inQuotes = true;
              quoteChar = arg[0];
              currentString += arg.slice(1);
          }
      } else if (arg.endsWith("'") || arg.endsWith("`")) {
          if (inQuotes && quoteChar === arg[arg.length - 1]) {
              currentString += ' ' + arg.slice(0, -1);
              result.push(currentString.trim());
              currentString = '';
              inQuotes = false;
          } else {
              result.push(arg);
          }
      } else {
          if (inQuotes) {
              currentString += ' ' + arg;
          } else {
              result.push(arg);
          }
      }
  }

  // 如果还有未结束的字符串，加入结果
  if (currentString) {
      result.push(currentString.trim());
  }

  return result;
}