import path from "pathe"
import fs from "fs"
import { config } from 'dotenv'
import { getPackages } from '@manypkg/get-packages';
import spawn from "cross-spawn";
import { logger } from "./log";

const root = process.cwd()
const ProcessENV: any = {}

export async function exp(monorepo: boolean, parsed: Record<string, string> = {}) {
  if (!monorepo) {
    write(`${root}/.env`, parsed)
    return
  }
  const { packages, root: packRoot } = await getPackages(process.cwd())
  if (packRoot.dir !== root) {
    logger.warn('Subproject exposes environment. If is correct, ignore this message.')
  }
  for (const pack of packages.filter(pack => pack.dir !== root)) {
    logger.wait(` - ${path.relative(root, pack.dir)}/.env`)
    write(`${pack.dir}/.env`, parsed)
  }
}

export async function cmd(command: string | string[], env?: Record<string, string>) {
  if (Array.isArray(command))
    command = command.join(' ')
  if (!command)
    throw new Error('Unable to run empty running script')
  const { execa } = await import('execa')

  const options: any = { stdio: 'inherit', env: { ...process.env, ...env } }
  const commands = command.split('&&').map(cmd => cmd.trim())
  for (let command of commands) {
    if (process.platform.startsWith('win') && command.includes('.sh') && !command.startsWith('sh ')) {
      command = 'sh ' + command
    }
    spawn.sync(command, options)
  }

}
export function load(file: string) {
  file = '.' + file
  const filepath = find(file)

  if (!filepath)
    return undefined

  if (file !== '.env.vault')
    return config({ path: filepath, processEnv: ProcessENV })

  const DOTENV_KEY = dokey('.env.key') || ProcessENV.DOTENV_KEY || process.env.DOTENV_KEY || dokey('.env')


  if (!DOTENV_KEY)
    throw new Error('No DOTENV_KEY found in .env|.env.key or process.env')

  return config({ DOTENV_KEY, path: filepath })
}

export function find(file: string) {
  let currentDir = root;

  while (currentDir !== path.parse(currentDir).root) {
    const envPath = path.join(currentDir, file);
    if (fs.existsSync(envPath)) {
      return envPath;
    }
    currentDir = path.dirname(currentDir);
  }

  return undefined;
}

export function uniq<T>(array: T[]) {
  return [...new Set([...array])]
}

export function m2fi(mod: string) {
  return mod !== 'env'
    ? mod === 'dotenv' ? 'env.vault' : `env.${mod}`
    : mod
}

export function dokey(file: string) {
  const envs = config({ processEnv: {}, DOTENV_KEY: undefined, path: find(file) })
  return envs.parsed?.DOTENV_KEY
}

export function write(filepath: string, parsed = {}) {
  const contents = Object.entries(parsed)
    .map(([key, value]) => `${key}=${value}`)
  const content = [
    "# This file is generated by lnv command",
    '# DO NOT ATTEMPT TO EDIT THIS FILE',
    contents.join('\n'),
  ].join('\n')
  fs.writeFileSync(filepath, content, 'utf-8')
}

export function quotes(argv: string[]) {
  const parsed: string[] = [];
  let currentString = '';
  let inQuotes = false;
  let quoteChar = '';

  for (const arg of argv) {
    if (arg.startsWith("'") || arg.startsWith("`")) {
      if (inQuotes) {
        currentString += ' ' + arg.slice(1);
      } else {
        inQuotes = true;
        quoteChar = arg[0];
        currentString += arg.slice(1);
      }
    } else if (arg.endsWith("'") || arg.endsWith("`")) {
      if (inQuotes && quoteChar === arg[arg.length - 1]) {
        currentString += ' ' + arg.slice(0, -1);
        parsed.push(currentString.trim());
        currentString = '';
        inQuotes = false;
      } else {
        parsed.push(arg);
      }
    } else {
      if (inQuotes) {
        currentString += ' ' + arg;
      } else {
        parsed.push(arg);
      }
    }
  }

  currentString && parsed.push(currentString.trim())

  return parsed;
}